# Fork-ID Technical Deep Dive: Logic, Design, and Implementation

  

## Table of Contents

1. [Core Concepts and Terminology](#core-concepts-and-terminology)

2. [Origins and Philosophy of Fork-ID Design](#origins-and-philosophy-of-fork-id-design)

3. [Technical Background of CRC32 Selection](#technical-background-of-crc32-selection)

4. [PoW Era: Block-Based Synchronization](#pow-era-block-based-synchronization)

5. [PoS Transition: The Merge and Technical Changes](#pos-transition-the-merge-and-technical-changes)

6. [Significance of Fixed Block Time](#significance-of-fixed-block-time)

7. [Testnet Design Philosophy](#testnet-design-philosophy)

8. [Mainnet History and Fork Sequence](#mainnet-history-and-fork-sequence)

9. [Test Case Design Principles](#test-case-design-principles)

10. [Implementation: Recognizing Blocks Set to 0](#implementation-recognizing-blocks-set-to-0)

11. [is_valid Validation Logic Analysis](#is_valid-validation-logic-analysis)

12. [Test Framework Analysis](#test-framework-analysis)

  

---

  

## Core Concepts and Terminology

  

### ENR (Ethereum Node Record)

  

**Definition:**

Ethereum Node Record is a standard format for identifying nodes and sharing information in the P2P network.

  

**Structure:**

```

ENR v4 (Ethereum Node Record Version 4)

├─ Node ID (public key based) : ~40 bytes

├─ IP Address : ~8 bytes

├─ Port : 4 bytes

├─ Fork-ID (after EIP-2124) : 12 bytes

├─ SeqNum (sequence number) : 8 bytes

├─ Other metadata : ~100 bytes

└─────────────────────────────────

Total size limit: 300 bytes

```

  

**Role:**

ENR is used in DHT (Distributed Hash Table) and Bootnodes to help peer discovery. Since Fork-ID is included in ENR, compatibility can be quickly verified before establishing TCP connections when discovering nodes.

  

---

  

### Peer Slot

  

**Definition:**

Each node limits the maximum number of peers it can connect to simultaneously. This is called "peer slots." The P2P Connection layer (eth protocol) manages this.

  

**Why needed:**

```

1. Resource Limits

- Each connection consumes memory, CPU, bandwidth

- Unlimited connections impossible

- Typically: max 50~100 peers

  

2. Network Stability

- Excessive connections degrade node performance

- DOS attack prevention

- Focus on quality peers

  

3. Fork-ID Role

- Incompatible peers waste slots

- Early filtering with Fork-ID for priority connection to good peers

```

  

---

  

### Difficulty Bomb (Ice Age)

  

**Definition:**

A mechanism that progressively increases Ethereum's mining difficulty.

  

**How it works:**

```

Difficulty increases exponentially based on block number:

  

difficulty = base_difficulty + 2^((block_number - ice_age_start) / 100000)

  

Characteristics:

- Initially: almost no impact

- Over time: difficulty increases rapidly

- Result: forces miners to prepare for Merge

```

  

**History:**

```

Introduced: Homestead (block 1,150,000)

Purpose: provide preparation time for PoS transition

  

Delays:

- Muir Glacier (block 9,200,000): delayed 5M blocks

- Arrow Glacier (block 13,773,000): delayed 10M blocks

- Gray Glacier (block 15,050,000): final delay

- Merge (block 17,034,870): completely removed (PoS begins)

```

  

---

  

## Origins and Philosophy of Fork-ID Design

  

### Background of EIP-2124

  

**Source:** [EIP-2124: Fork identifier for chain compatibility checks](https://eips.ethereum.org/EIPS/eip-2124)

**Author:** Peter Szilagyi (go-ethereum core dev)

**Status:** Final

  

#### The Actual Problem

  

From the EIP-2124 spec:

  

> "nodes in the Ethereum network try to find each other by establishing random connections... hoping that they found a useful peer (same genesis, same forks)"

  

More specifically:

  

> "establish a TCP/IP connection, wrap it with RLPx cryptography, then execute an `eth` handshake"

  

#### Before EIP-2124: Had to reach handshake to verify chain info

  

**Problem before EIP-2124:**

```

1. Establish TCP/IP connection

2. Wrap with RLPx encryption

3. Start eth handshake

4. Exchange Status messages

├─ Check ProtocolVersion

├─ Check NetworkID (only this for compatibility)

└─ Check Genesis hash

5. Disconnect if different chain

  

Problem: NetworkID alone can't distinguish!

- Mainnet ID = 1

- Ethereum Classic ID = 61

- Sepolia ID = 11155111

→ Forks sharing the same genesis can't be distinguished

→ New criteria needed for each hard fork

```

  

#### EIP-2124's Solution

  

From EIP-2124:

  

> "by aggressively cutting off incompatible nodes from each other

> we can extract a lot more value from the public nodes,

> making the entire P2P network much more robust and reliable"

  

**Core idea: Pre-filter at Discovery Layer**

  

Include Fork-ID in ENR (Ethereum Node Record):

```

ENR structure (300 bytes limit):

├─ base info (IP, Port) : ~100 bytes

├─ fork_id : 12 bytes ← NEW! (4 bytes hash + 8 bytes next)

└─ other info

```

  

**Improved process:**

```

After EIP-2124:

1. Peer discovery (DHT or Bootnodes)

2. Read Fork-ID from ENR (very fast!)

3. Validate Fork-ID

├─ Compatible? → Attempt TCP connection

└─ Incompatible? → Skip (don't connect!)

4. Only connect to compatible peers via TCP

  

→ Incompatible peers filtered from the start!

→ TCP/RLPx/Handshake cost savings!

```

  

### EIP-2124 Specification

  

#### Fork-ID Structure

  

```

Fork-ID = RLP([FORK_HASH, FORK_NEXT])

  

where:

FORK_HASH: 4-byte CRC32 checksum

= CRC32(genesis_hash + sorted(activated_fork_blocks))

  

FORK_NEXT: next fork's block number or timestamp

= first fork not yet experienced by the node

```

  

---

  

## Technical Background of CRC32 Selection

  

### Why CRC32?

  

From EIP-2124 Rationale:

  

> "Why CRC32 over Keccak256? CRC32 was designed for exactly

> this purpose—flattening arbitrary data into fixed checksums.

> Cryptographic properties are unnecessary since nodes can lie anyway."

  

**Key insight:**

```

Fork-ID doesn't need cryptographic security

→ Nodes can lie anyway (can't verify without cooperation)

→ Therefore performance and efficiency are more important

```

  

**Official comparison:**

  

| Hash Function | Size | Design Purpose | Speed | EIP-2124 Evaluation |

|--------------|------|----------------|-------|---------------------|

| **CRC32** | **4 bytes** | Error detection | **Very fast** | ✅ Ideal |

| Keccak256 | 32 bytes | Cryptographic security | Slow | ❌ Overkill |

| MD5 | 16 bytes | Cryptography | Medium | ❌ Weak security |

| SHA-1 | 20 bytes | Cryptography | Medium | ❌ Weak security |

  

**Discovery ENR size constraint:**

  

From EIP-2124 Rationale:

> "Discovery ENRs have only 300 bytes total.

> CRC32 checksums suffice for collision prevention across

> Ethereum networks."

  

---

  

## PoW Era: Block-Based Synchronization

  

### Early Ethereum (2015-2022)

  

#### The Problem

  

```

July 30, 2015: Ethereum genesis block created

├─ Mining begins

├─ Block time: irregular (10-20 seconds)

└─ Average: ~13 seconds (target)

```

  

**Why irregular?**

```

PoW (Proof of Work) = solving mining puzzle

├─ Puzzle difficulty ∝ network hash rate

└─ Hash rate changes → difficulty adjustment needed

→ Block time varies

```

  

#### Solution: Block Number Based Forks

  

```

"Forks activate at specific block numbers"

  

Example: Homestead fork

"Apply Homestead rules from block 1,150,000"

  

Why?

- All nodes track the same blockchain

- Block numbers are absolute and immutable

- Time is relative but block numbers are absolute

```

  

**Mainnet's PoW forks:**

```

Block 0: Genesis

Block 1,150,000: Homestead ← fork-id changes

Block 1,920,000: DAO Fork ← fork-id changes

Block 2,463,000: EIP150 (Tangerine Whistle) ← fork-id changes

Block 2,675,000: EIP155/158 (Spurious Dragon) ← fork-id changes

Block 4,370,000: Byzantium ← fork-id changes

Block 7,280,000: Constantinople ← fork-id changes

Block 7,280,000: Petersburg ← fork-id changes (same block)

Block 9,069,000: Istanbul ← fork-id changes

Block 9,200,000: Muir Glacier ← fork-id changes

Block 12,244,000: Berlin ← fork-id changes

Block 12,965,000: London ← fork-id changes

Block 13,773,000: Arrow Glacier ← fork-id changes

Block 15,050,000: Gray Glacier ← fork-id changes

Block 17,034,870: Merge (transition to PoS!) ← fork-id changes, now timestamp-based

```

  

---

  

## PoS Transition: The Merge and Technical Changes

  

### The Merge (September 15, 2022)

  

#### Historical Event

  

```

September 15, 2022, block 17,034,870

└─ Ethereum PoW → PoS transition (The Merge)

```

  

#### Technical Changes

  

```

PoW Era:

├─ Block creation: miners solve puzzle

├─ Block time: irregular (avg 13 seconds)

├─ Consensus: Longest Chain Rule

└─ Fork-ID: block number based

  

PoS Era:

├─ Block creation: validators take turns

├─ Block time: exactly 12 seconds (Slot: 12s, Epoch: 32 slots)

├─ Consensus: Finality

└─ Fork-ID: timestamp based

```

  

#### Why Change to Timestamps?

  

```

Characteristics of PoS era:

1. Precise time synchronization

- Beacon Chain is designed around time

- Each slot = 12 second intervals

- All validators track the same slot number

  

2. Block number becomes less meaningful

PoW: block time = irregular → can't predict time from block number

PoS: block time = precise → can predict time from block number!

but timestamps are still more accurate

  

3. New criteria for fork activation

"Activate fork at timestamp X"

→ All nodes judge based on the same UTC time

```

  

---

  

## Significance of Fixed Block Time

  

### PoS Slot Mechanism

  

#### Structure

  

```

Epoch 0 (32 slots, 384 seconds)

├─ Slot 0 (12s): Validator 0 creates block

├─ Slot 1 (12s): Validator 1 creates block

├─ Slot 2 (12s): Validator 2 creates block

└─ ... (32 slots)

  

Epoch 1 (32 slots, 384 seconds)

└─ ...

```

  

**Characteristics:**

```

Slot number = unique, increasing time index

Slot Duration = always 12 seconds

  

Therefore:

- Actual time = Slot 0 start time + (Slot number × 12 seconds)

- All nodes track the same slot number

- Entire network is time-synchronized

```

  

### Mainnet's PoS Forks

  

```

Block 17,034,870: Merge (PoS begins)

↓ Transition to timestamp-based

Timestamp 1681338455 (2023-04-12): Shanghai ← fork-id changes

Timestamp 1710338135 (2024-03-13): Cancun ← fork-id changes

Timestamp 1746612311 (2025-01-07): Prague ← fork-id changes

Timestamp 1764798551 (2025-10-05): Osaka ← fork-id changes

Timestamp 1765290071 (2025-10-09): BPO1 ← fork-id changes

Timestamp 1767747671 (2025-11-07): BPO2 ← fork-id changes

```

  

---

  

## Testnet Design Philosophy

  

### Holesky: "PoS-Only Testnet"

  

#### Design Intent

  

```

"We want to test clients in a real PoS environment"

```

  

#### Characteristics

  

```json

{

"config": {

"mergeNetsplitBlock": 0, // PoS from the start!

"shanghaiTime": 1696000704,

// All PoW forks omitted

}

}

```

  

**Design Philosophy:**

```

1. Skip history

"We don't need PoW history"

→ All PoW forks placed at block 0

  

2. Fast testing

→ All PoW forks active from block 0

→ Only test PoS from block 1

  

3. Simulate current environment

→ Immediately experience Mainnet's current state (PoS)

→ No need to test PoW environment

```

  

### Sepolia: "PoW → PoS Transition Simulation"

  

#### Design Intent

  

```

"A realistic testnet that experiences both PoW and PoS"

```

  

#### Characteristics

  

```json

{

"config": {

"homesteadBlock": 0, // all 0 (meaningless)

"eip150Block": 0,

// ...

"mergeNetsplitBlock": 1735371, // first meaningful fork

"shanghaiTime": 1677557088,

}

}

```

  

### Mainnet: "Complete History"

  

#### Design Intent

  

```

"We record all of Ethereum's history"

```

  

#### Characteristics

  

```json

{

"config": {

"homesteadBlock": 1150000, // meaningful!

"eip150Block": 2463000, // meaningful!

"eip155Block": 2675000, // meaningful!

// ... 12 forks, all meaningful ...

"mergeNetsplitBlock": 17034870,

"shanghaiTime": 1681338455,

}

}

```

  

---

  

## is_valid Validation Logic Analysis

  

### Overview

  

The `is_valid()` function validates whether a remote peer's Fork-ID is compatible with the local node. It sequentially applies the 4 validation rules defined in EIP-2124.

  

### Function Signature

  

```rust

pub fn is_valid(

&self, // Local Fork-ID

remote: Self, // Remote peer's Fork-ID

latest_block_number: u64, // Local's latest block number

head_timestamp: u64, // Local's latest timestamp

chain_config: ChainConfig, // Chain configuration

genesis_header: BlockHeader,// Genesis header

) -> bool

```

  

### Validation Flow

  

```

┌─────────────────────────────────────────────────────────────┐

│ is_valid() execution start │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 1. Determine head value │

│ head_timestamp >= TIMESTAMP_THRESHOLD (1438269973)? │

│ → YES: head = head_timestamp (PoS mode) │

│ → NO: head = latest_block_number (PoW mode) │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 2. Rule #1: fork_hash match check │

│ remote.fork_hash == self.fork_hash? │

│ → YES: validate fork_next │

│ - remote.fork_next <= head && != 0? → false │

│ - otherwise → true │

│ → NO: proceed to rules #2, #3, #4 │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 3. Generate all valid Fork-ID combinations │

│ valid_combinations = get_all_fork_id_combinations() │

│ [(hash_0, fork_0), (hash_1, fork_1), ..., (hash_n, 0)] │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 4. Iterate combinations checking rules #2, #3 │

│ │

│ is_subset = true (checking past state relative to local) │

│ │

│ for (fork_hash, fork_next) in valid_combinations: │

│ │ │

│ ├─ if is_subset: │

│ │ Rule #2: is remote a subset of local? │

│ │ remote.fork_hash == fork_hash && │

│ │ remote.fork_next == fork_next → return true │

│ │ │

│ ├─ else: │

│ │ Rule #3: is remote a superset of local? │

│ │ remote.fork_hash == fork_hash → return true │

│ │ │

│ └─ if fork_hash == self.fork_hash: │

│ is_subset = false (now checking future state) │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 5. Rule #4: All checks failed │

│ → return false │

│ "Local or remote needs software update" │

└─────────────────────────────────────────────────────────────┘

```

  

### EIP-2124 Validation Rules (Actual Code)

  

**Head value determination logic**

  

```rust

// crates/common/types/fork_id.rs:80-85

// TIMESTAMP_THRESHOLD = 1438269973 (near Ethereum Genesis timestamp)

let head = if head_timestamp >= TIMESTAMP_THRESHOLD {

head_timestamp // PoS mode: use timestamp

} else {

latest_block_number // PoW mode: use block number

};

```

  

**Rule #1: fork_hash match**

  

```rust

// crates/common/types/fork_id.rs:87-94

if remote.fork_hash == self.fork_hash {

// validation rule #1

if remote.fork_next <= head && remote.fork_next != 0 {

debug!("Future fork already passed locally.");

return false;

}

return true;

}

```

  

```

When local and remote fork_hash are identical:

- Both nodes have experienced the same fork history

- Only need to validate fork_next

- If remote.fork_next points to an already-passed fork → reject

- Otherwise → allow

```

  

**Rule #2: Remote is subset (past state)**

  

```rust

// crates/common/types/fork_id.rs:101-106

for (fork_hash, fork_next) in valid_combinations {

if is_subset {

// The remote hash is a subset of the local past forks (rule #2)

if remote.fork_hash == fork_hash && remote.fork_next == fork_next {

return true;

}

}

// ...

}

```

  

```

When remote node is in a past state relative to local:

- Remote's fork_hash matches one of local's past fork_hashes

- Remote's fork_next must also match that point's fork_next

- Can catch up through synchronization → allow

```

  

**Why must fork_next also match?**

  

```

valid_combinations example (chronological):

[(0xfc64ec04, 1150000), // Genesis → Homestead

(0x97c2c34c, 1920000), // Homestead → DAO

(0x91d1f948, 2463000), // DAO → EIP150

...

(0xdce96c2d, 1710338135), // Shanghai → Cancun ← local current position

...]

  

If only fork_hash matches:

- Remote experienced DAO fork, that's certain

- But if it doesn't know "what's the next fork":

→ Chain configuration might be different

→ Could be a diverged chain like Ethereum Classic

  

If both fork_hash + fork_next match:

- Remote experienced DAO fork AND

- Knows next fork is EIP150 (2463000)

→ Definitely has the same Mainnet chain configuration

→ Just a state that hasn't synced yet

```

  

**Rule #3: Remote is superset (future state)**

  

```rust

// crates/common/types/fork_id.rs:107-117

for (fork_hash, fork_next) in valid_combinations {

// ...

} else {

// The remote hash is a superset of the local past forks (rule #3)

if remote.fork_hash == fork_hash {

return true;

}

}

if fork_hash == self.fork_hash {

// From this point on, if we have a match, it means the remote fork hash

// is a superset of our local past forks.

is_subset = false;

}

}

```

  

```

When remote node is in a future state relative to local:

- After is_subset becomes false (after passing local fork_hash)

- Remote's fork_hash matches one of local's future fork_hashes

- fork_next is not validated (since it's a future state)

- Local can catch up after software update → allow

```

  

**Rule #4: Incompatible**

  

```rust

// crates/common/types/fork_id.rs:119-121

// rule #4

debug!("Local or remote needs software update.");

false

```

  

```

When none of the above 3 rules apply:

- Different chain or completely different fork path

- No matching combination found after iterating all valid_combinations

- "Local or remote needs software update" → reject

```

  

---

  

## Test Framework Analysis

  

### Test Structure

  

```rust

struct TestCase {

head: u64, // Block number to test

time: u64, // Timestamp to test

fork_id: ForkId,// Fork-ID value to validate

is_valid: bool, // Expected result (compatibility)

}

```

  

### assert_test_cases Function

  

```rust

fn assert_test_cases(

test_cases: Vec<TestCase>,

chain_config: ChainConfig,

genesis_header: BlockHeader

) {

for test_case in test_cases {

// 1. Create local Fork-ID

let fork_id = ForkId::new(

chain_config,

genesis_header.clone(),

test_case.time, // timestamp

test_case.head // block number

);

  

// 2. Call is_valid for validation

assert_eq!(

fork_id.is_valid(

test_case.fork_id, // Remote Fork-ID to test

test_case.head,

test_case.time,

chain_config,

genesis_header.clone()

),

test_case.is_valid // Compare with expected result

)

}

}

```

  

### Test Execution Flow

  

```

┌─────────────────────────────────────────────────────────────┐

│ mainnet_test_cases() test start │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 1. Load Genesis file │

│ genesis.json → Genesis struct │

│ genesis.get_block().header → BlockHeader │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 2. Create test case array │

│ vec![ │

│ TestCase { head: 0, time: 0, fork_id: {...}, ... }, │

│ TestCase { head: 1149999, ... }, │

│ ... │

│ ] │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 3. Call assert_test_cases() │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────┐

│ Iterate for each TestCase │

└─────────────────────────────────────────┘

│

┌────────────────────┼────────────────────┐

▼ ▼ ▼

┌─────────────┐ ┌─────────────┐ ┌─────────────┐

│ TestCase 1 │ │ TestCase 2 │ │ TestCase N │

│ head: 0 │ │ head: ... │ │ head: ... │

│ time: 0 │ │ time: ... │ │ time: ... │

└─────────────┘ └─────────────┘ └─────────────┘

│ │ │

▼ ▼ ▼

┌─────────────────────────────────────────────────────────────┐

│ 4. Call ForkId::new() │

│ Input: chain_config, genesis_header, time, head │

│ Output: Local Fork-ID (fork_hash, fork_next) │

│ │

│ Internal operation: │

│ - Initialize CRC32 hasher (with genesis_hash) │

│ - Iterate through block/timestamp-based forks │

│ - Accumulate activated forks up to head/time into CRC32 │

│ - Set next fork number as fork_next │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 5. Call is_valid() │

│ Input: test_case.fork_id (target to validate) │

│ Output: bool (compatibility) │

│ │

│ Internal operation: │

│ - Apply EIP-2124's 4 rules sequentially │

│ - Rule #1: fork_hash match check │

│ - Rule #2: subset check (past state) │

│ - Rule #3: superset check (future state) │

│ - Rule #4: false if all fail │

└─────────────────────────────────────────────────────────────┘

│

▼

┌─────────────────────────────────────────────────────────────┐

│ 6. assert_eq!() verification │

│ is_valid() result == test_case.is_valid │

│ → match: test passes │

│ → mismatch: test fails (panic) │

└─────────────────────────────────────────────────────────────┘

```

  

### Mainnet Test Case Verification Examples

  

**Example 1: Genesis (block 0)**

```

Input:

head = 0

time = 0

test_fork_id = { hash: 0xfc64ec04, next: 1150000 }

  

ForkId::new() execution:

- hasher.update(genesis_hash)

- next fork = 1150000 (Homestead)

- fork_hash = CRC32(genesis_hash) = 0xfc64ec04

- fork_next = 1150000

  

is_valid() execution:

- Rule #1: fork_hash match (0xfc64ec04 == 0xfc64ec04)

- fork_next validation: 1150000 > head(0) → OK

- return true

  

Result: true == test_case.is_valid(true) → PASS

```

  

**Example 2: Homestead activation (block 1,150,000)**

```

Input:

head = 1150000

time = 0

test_fork_id = { hash: 0x97c2c34c, next: 1920000 }

  

ForkId::new() execution:

- hasher.update(genesis_hash)

- fork 1150000 <= head → hasher.update(1150000)

- next fork = 1920000 (DAO)

- fork_hash = CRC32(genesis_hash + 1150000) = 0x97c2c34c

- fork_next = 1920000

  

is_valid() execution:

- Rule #1: fork_hash match (0x97c2c34c == 0x97c2c34c)

- fork_next validation: 1920000 > head(1150000) → OK

- return true

  

Result: true == test_case.is_valid(true) → PASS

```

  

**Example 3: Shanghai activation (timestamp 1681338455)**

```

Input:

head = 20000000 (ignored in PoS)

time = 1681338455

test_fork_id = { hash: 0xdce96c2d, next: 1710338135 }

  

ForkId::new() execution:

- hasher.update(genesis_hash)

- All block-based forks processed (fork_next = 0)

- Timestamp fork processing begins

- 1681338455 <= time → hasher.update(1681338455)

- next fork = 1710338135 (Cancun)

- fork_hash = 0xdce96c2d

- fork_next = 1710338135

  

is_valid() execution:

- head determination: time >= TIMESTAMP_THRESHOLD → head = 1681338455

- Rule #1: fork_hash match

- fork_next validation: 1710338135 > head(1681338455) → OK

- return true

  

Result: true == test_case.is_valid(true) → PASS

```

  

---

  

## Conclusion

  

### Fork-ID Journey

  

```

2015: Ethereum begins (block-based)

↓

2016-2019: Multiple forks, PoW progresses

↓

2019-2022: PoS preparation, difficulty bomb management

↓

September 2022: The Merge (PoW → PoS)

↓

Present: PoS era, regular upgrades

↓

Future: More expanded network

```

  

### Technical Evolution

  

```

PoW Era:

- Irregular block generation

- Block number based forks

- Fork-ID = CRC32(genesis + activated_blocks)

  

PoS Era:

- Precise 12-second block time

- Timestamp based forks

- Fork-ID = CRC32(genesis + activated_timestamps)

```

  

### Significance of Tests

  

```

Holesky: "We only need PoS environment"

Sepolia: "We simulate PoW → PoS transition"

Mainnet: "We record complete history"

  

Adding Mainnet tests:

→ Ensures compatibility with Go-Ethereum

→ Validates both block-based and timestamp-based

→ Ensures accuracy of 9 years of history

```

  

---

  

**Document Type:** Technical Research Paper

**Version:** 1.0

**Depth Level:** Advanced

**Target Audience:** Ethereum Protocol Developers, L1/L2 Engineers

**Date:** 2026-02-04