## Q: step36은 역전파라면서 왜 x부터 연산해?

  

역전파를 하려면 순전파가 먼저 필요하다.

순전파로 계산 그래프를 만들어야 역전파로 거슬러 올라갈 수 있다.

  

## Q: 순전파를 전부 진행한 뒤에 z, y순으로 역전파를 실행하는 거 아니야?

  

일반적인 경우는 그렇다. step37이 그 예시:

  

```

순전파: x, c -> t -> y

역전파: y -> t -> x, c

```

  

step36이 특수한 이유는 z를 만들려면 gx가 필요한데, gx는 y.backward()를 해야 얻을 수 있기 때문이다.

  

```

z = gx^3 + y

|

gx는 어디서 오나? -> y.backward()의 결과

```

  

그래서 중간에 역전파를 끼워 넣을 수밖에 없다.

  

## Q: 결국 역전파랑 순전파는 실행 순서가 같아?

  

코드 실행 흐름은 항상 순전파 -> 역전파 순서다.

  

```

1. let y = x.pow(2.0); // 순전파

2. y.backward(true); // 역전파

3. let z = &gx.pow(3.0) + &y; // 순전파

4. z.backward(false); // 역전파

```

  

그래프를 먼저 만들어야(순전파) 거슬러 올라갈 수(역전파) 있으니까, 코드에서는 항상 순전파가 먼저 나온다.

  

단, 각 backward 내부에서는 그래프를 출력 -> 입력 방향(역방향)으로 따라간다.

  

## Q: step37에서는 그 부분을 개선한 거야?

  

아니다. step36과 step37은 다른 주제:

  

- step36: 기울기를 새 계산에 활용 (이중 역전파 응용)

- step37: sum 함수 추가 (텐서 연산)

  

step37에서 순전파 -> 역전파 순서가 깔끔한 건 개선이 아니라, 중간에 기울기를 꺼내 쓸 필요가 없는 보통의 경우이기 때문이다.