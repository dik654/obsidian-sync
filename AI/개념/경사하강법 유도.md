## 목표

  

함수 f(x)의 최솟값을 찾고 싶다.

  
## 테일러 전개 공식

```

f(x + Δx) = f(x) + f'(x)/1!·Δx + f''(x)/2!·Δx² + f'''(x)/3!·Δx³ + ...

```

각 차수는 **이전 차수의 변화율**

| 차수       | 의미       | 설명                    |
| -------- | -------- | --------------------- |
| f(x)     | 값        | 현재 위치의 높이             |
| f'(x)    | 기울기      | 높이가 **얼마나 빠르게** 변하는가  |
| f''(x)   | 휘어짐 (곡률) | 기울기가 **얼마나 빠르게** 변하는가 |
| f'''(x)  | 휘어짐의 변화  | 곡률이 **얼마나 빠르게** 변하는가  |
| f''''(x) | 그 변화의 변화 | ...                   |

## 1단계: 테일러 전개 (1차)

  

현재 위치 x에서 조금 움직인 x + Δx에서의 함수값을 근사하면:

  

```

f(x + Δx) ≈ f(x) + f'(x)·Δx

```

  

**f(x + Δx)를 f(x)보다 작게** 만들려면, 즉 `f'(x)·Δx < 0`이어야 한다.

  

## 2단계: Δx는 항상 음수면 되는 거 아닌가?

  

아니다. f'(x)의 부호에 따라 Δx의 방향이 달라져야 한다.

  

```

f(x)

\ /

f'<0 \ / f'>0

여기선 \ / 여기선

→으로 \ / ←으로

가야함 \/ 가야함

최솟값

```

  

- `f'(x) > 0` (오르막) → Δx는 **음수**여야 함 (왼쪽으로)

- `f'(x) < 0` (내리막) → Δx는 **양수**여야 함 (오른쪽으로)

  

f'(x) < 0인 곳에서 Δx를 음수로 잡으면 **반대쪽으로 가버린다.**

  

그래서 "항상 음수"가 아니라 **"f'(x)에 따라 부호가 바뀌는 것"**이 필요하다.

  

## 3단계: -f'(x)가 자동으로 올바른 방향을 가리킨다

  

어떤 수든 앞에 `-`를 붙이면 부호가 반대가 된다:

  

```

f'(x) = 3 → -f'(x) = -3 (음수, 왼쪽으로) ✓

f'(x) = -5 → -f'(x) = 5 (양수, 오른쪽으로) ✓

```

  

f'(x)의 부호가 뭐든, `-f'(x)`는 **항상 최솟값 방향**을 가리킨다.

  

그래서:

  

```

Δx = -f'(x)

```

  

## 4단계: 학습률 추가

  

`-f'(x)`만 쓰면 이동량이 기울기 크기에 완전히 종속된다.

보폭을 조절하기 위해 계수 η(학습률, η > 0)를 붙인다:

  

```

Δx = -η · f'(x)

```

  

- η가 크면 → 크게 이동

- η가 작면 → 조금 이동

  

## 5단계: 갱신 규칙

  

```

x_new = x + Δx = x - η · f'(x)

```

  

이것이 경사하강법의 전부다.

  

## 감소 보장 증명

  

Δx = -η · f'(x)를 대입하면:

  

```

f'(x) · Δx = f'(x) · (-η · f'(x)) = -η · [f'(x)]²

```

  

- `[f'(x)]²` → 제곱이라 항상 ≥ 0

- `-η` → 항상 음수 (η > 0이므로)

  

따라서 `-η · [f'(x)]² ≤ 0` → **항상 감소 보장.**

  

## 다변수 확장

  

변수가 여러 개면 미분이 기울기 벡터(gradient)로 바뀔 뿐, 동일하다:

  

```

x₀ = x₀ - η · ∂f/∂x₀

x₁ = x₁ - η · ∂f/∂x₁

```

  

코드로 보면:

  

```rust

x0.set_data(x0.data() - lr * &g0); // g0 = ∂y/∂x₀

x1.set_data(x1.data() - lr * &g1); // g1 = ∂y/∂x₁

```

  

## 요약

  

```

"반대 방향으로 가자" → -f'(x)

"보폭을 조절하자" → -η · f'(x)

"x를 갱신하자" → x = x - η · f'(x)

```